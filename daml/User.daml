daml 1.2

module User where

-- Simple Party -> to UserName capabilities

import qualified DA.Text as T
import qualified DA.Next.Map as M

{-
  Helper Functions
-}
type UserNameMap = M.Map Text Party

nextAvailable : Text -> Text
nextAvailable s =
  let rightNumbers = T.takeWhileEnd T.isDigit s
      leftLetters = T.take (T.length s - T.length rightNumbers) s
  in
  case T.parseInt rightNumbers of
    None    -> leftLetters <> "1"
    Some n  -> leftLetters <> show (n + 1)

data Common = Common with
  admin : Party
  public : Party
  user : Party
  userName : Text
    deriving (Eq, Show)

freeUserName : Int -> Common -> Update (ContractId Session)
freeUserName numberOfRenames common = do
  userNameOpt <- lookupByKey @UserName (common.admin, common.userName)
  case userNameOpt of
    None -> do
      userNameId <- create UserName with common
      create Session with common, ..
    Some _userNameId -> do
      freeUserName numberOfRenames (common with userName = nextAvailable common.userName)

nextAvailableSession : Int -> Common -> Update (ContractId Session)
nextAvailableSession numberOfRenames common = do
  currentSessionOpt <- lookupByKey @Session (common.admin, common.user)
  case currentSessionOpt of
    Some sessionId -> do return sessionId    -- No renames by creating new Session Requests!
    None -> do freeUserName numberOfRenames common

{-
  Templates that describes the interaction.
-}

{- Each user/party has a Session that codifies an agreement between that
   user/party and an administrator (of the ledger/business-application).

   In this instance there are two pieces of business logic that is codified:
    1. A public userName, that makes for a convenient way, as chosen/suggested
      by the user, and agreed upon by the admin, to refer to the user.
      This information is made public by having the `public` party be an observer
      on the `UserName` contract.
    2. A private number of renames count. This information is stored only in the
       Session contract.
 -}
template Session
  with
    common : Common
    userNameId : ContractId UserName
    numberOfRenames : Int
  where
    signatory common.admin, common.user

    key (common.admin, common.user) : (Party, Party)
    maintainer key._1

    controller common.user can
      Rename : ContractId SessionRenameRequest
        with
          newUserName : Text
        do
          assert $ newUserName /= common.userName
          archive userNameId
          create SessionRenameRequest with
                    numberOfRenames = numberOfRenames + 1
                    common = common with userName = newUserName

-- A user needs to request a Session via this contract.
template SessionRequest
  with
    common : Common
  where
    signatory common.user
    key common.user : Party
    maintainer key

    controller common.admin can
      Acknowledge : ContractId Session
        do
          nextAvailableSession 0 common

-- A user can only ask for a rename if they already have a session.
template SessionRenameRequest
  with
    common : Common
    numberOfRenames : Int
  where
    signatory common.user, common.admin           -- A user can't create this request
    key common.user : Party
    maintainer key

    controller common.admin can
      AcknowledgeRename : ContractId Session
        do
          nextAvailableSession numberOfRenames common

{- Username assignments maintained by the admin but visible to all users via public party. -}
template UserName
  with
    common : Common
  where
    signatory common.admin
    observer common.public
    key (common.admin, common.userName) : (Party, Text)
    maintainer key._1

-- Tests --

testNextAvailable = scenario do
  assert $ nextAvailable "" == "1"
  assert $ nextAvailable "1" == "2"
  assert $ nextAvailable "9" == "10"

  assert $ nextAvailable "bob" == "bob1"
  assert $ nextAvailable "bob1" == "bob2"
  assert $ nextAvailable "bob9" == "bob10"

testRequestsAndAliases = scenario do
  alice <- getParty "alice"
  bob <- getParty "bob"
  admin <- getParty "admin"
  public <- getParty "public"

  let alicesDesiredUserName = "Alice"
  alicesReq <- submit alice do
                  create SessionRequest with
                    common = Common with user = alice, userName = alicesDesiredUserName, ..

  alicesSessionId <- submit admin do exercise alicesReq Acknowledge
  alicesSession <- submit alice do fetch alicesSessionId
  assert $ alicesSession.common.userName == alicesDesiredUserName

  bobsReq <- submit bob do
                  create SessionRequest with
                    -- tries to use the same userName
                    common = Common with user = bob, userName = alicesDesiredUserName, ..

  bobsSessionId <- submit admin do exercise bobsReq Acknowledge
  bobsSession <- submit bob do fetch bobsSessionId
  assert $ bobsSession.common.userName /= alicesDesiredUserName

  (_aId, alicesUserName) <- submit public do fetchByKey @UserName (admin, alicesDesiredUserName)
  assert $ alicesUserName.common.user == alice

  let bobsNewName = "Bobby"
  bobsRename <- submit bob do
                  exercise bobsSessionId Rename with
                    newUserName = bobsNewName

  bobsSessionId <- submit admin do exercise bobsRename AcknowledgeRename

  (_bId, bobsUserName) <- submit public do fetchByKey @UserName (admin, bobsNewName)
  assert $ bobsUserName.common.user == bob

  let bobsSecondName = "Rober"
  bobsRename <- submit bob do
                  exercise bobsSessionId Rename with
                    newUserName = bobsSecondName

  bobsSessionId <- submit admin do exercise bobsRename AcknowledgeRename
  bobsSession <- submit bob do fetch bobsSessionId
  assert $ bobsSession.numberOfRenames == 2

  (_bId, bobsUserName) <- submit public do fetchByKey @UserName (admin, bobsSecondName)
  assert $ bobsUserName.common.user == bob

  return ()